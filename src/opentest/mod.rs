use clap::ArgMatches;
use std::fs::OpenOptions;
use std::path::PathBuf;
use std::ops::RangeInclusive;
use std::process::{Command, Stdio};

use crate::paths::{fix_ex_path, path_child};

use indicatif::{ProgressBar, ProgressStyle};

type Range = RangeInclusive<usize>;

struct Config{
    fd_in: PathBuf,
    fd_out: PathBuf,
    exec: PathBuf,
    outname: String,
    rg: Range
}

fn get_config(args: &ArgMatches) -> Config{
    let folder = PathBuf::from(args.value_of("fd").unwrap_or("."));
    let exec = fix_ex_path(args.value_of("s").unwrap_or("."));
    let outname = args.value_of("out").unwrap_or("output?.txt");
    let begin = args.value_of("b").unwrap_or("1").parse().unwrap_or(1);
    let end = args.value_of("e").unwrap_or("10").parse().unwrap_or(10);
    Config{
        fd_in: path_child(&folder, "in"),
        fd_out: path_child(&folder, "out"),
        exec,
        outname: outname.to_owned(),
        rg: Range::new(begin, end)
    }
}

fn get_number(s: &str) -> usize{
    let mut i: usize = 0;
    for c in s.chars(){
        if c >= '0' && c <= '9'{
            i *= 10;
            i += c as usize - '0' as usize;
        }
    }
    return i;
}

fn run(cfg: &Config, p: &PathBuf, idx: usize) {
    let infile = std::fs::File::open(p).unwrap();
    let outname = cfg.outname.replace("?", &format!("{}",idx));
    let outfile = OpenOptions::new().write(true)
        .create(true).open(path_child(&cfg.fd_out, &outname)).unwrap();
    Command::new(&cfg.exec)
        .stdin(Stdio::from(infile))
        .stdout(Stdio::from(outfile))
        .spawn().ok();  
}

pub fn launch(args: &ArgMatches){
    let cfg = get_config(args);
    let all =  cfg.rg.end() - cfg.rg.start() + 1;

    let bar = ProgressBar::new(all as u64);
    bar.set_style(ProgressStyle::default_bar()
        .template("[{elapsed}] {wide_bar} {pos} | {eta}")
        .progress_chars("## ")
    );
    bar.inc(0);

    for entry in cfg.fd_in.read_dir().unwrap(){
        if let Ok(entry) = entry{
            if !entry.file_name().to_str().unwrap().ends_with(".txt"){
                continue;
            }
            let i = get_number(entry.file_name().to_str().unwrap());
            if !cfg.rg.contains(&i){
                continue;
            }
            run(&cfg, &entry.path(), i);
            bar.inc(1);
        }
    }
    bar.finish();
}