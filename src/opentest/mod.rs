extern crate num_cpus;

use clap::ArgMatches;
use indicatif::{ProgressBar, ProgressStyle};

use std::fs::OpenOptions;
use std::path::PathBuf;
use std::ops::RangeInclusive;
use std::process::{Command, Stdio};

use std::thread;
use std::sync::atomic::{AtomicUsize, Ordering};

use crate::paths::{fix_ex_path, path_child};



type Range = RangeInclusive<usize>;

struct Config{
    fd_in: PathBuf,
    fd_out: PathBuf,
    exec: PathBuf,
    outname: String,
    rg: Range, 
    threads: usize
}

fn get_config(args: &ArgMatches) -> Config{
    let folder = PathBuf::from(args.value_of("fd").unwrap_or("."));
    let exec = fix_ex_path(args.value_of("s").unwrap_or("."));
    let outname = args.value_of("out").unwrap_or("output?.txt");
    let begin = args.value_of("b").unwrap_or("1").parse().unwrap_or(1);
    let end = args.value_of("e").unwrap_or("10").parse().unwrap_or(10);
    let mut threads = args.value_of("t").unwrap_or("NONE").parse().unwrap_or(num_cpus::get());
    if threads <= 0{
        threads = 1;
    }
    Config{
        fd_in: path_child(&folder, "in"),
        fd_out: path_child(&folder, "out"),
        exec,
        outname: outname.to_owned(),
        rg: Range::new(begin, end),
        threads
    }
}

fn get_number(s: &str) -> usize{
    let mut i: usize = 0;
    for c in s.chars(){
        if c >= '0' && c <= '9'{
            i *= 10;
            i += c as usize - '0' as usize;
        }
    }
    return i;
}

fn run(cfg: &Config, p: &PathBuf, idx: usize) {
    let infile = std::fs::File::open(p).unwrap();
    let outname = cfg.outname.replace("?", &format!("{}",idx));
    let outpath = path_child(&cfg.fd_out, &outname);
    std::fs::remove_file(&outpath).ok();
    let outfile = OpenOptions::new().write(true)
        .create(true).open(outpath).unwrap();  
    Command::new(&cfg.exec)
        .stdin(Stdio::from(infile))
        .stdout(Stdio::from(outfile))
        .output().unwrap();
}


struct Task{
    path: PathBuf,
    idx: usize
}

static DONE: AtomicUsize = AtomicUsize::new(0);

fn launch_threads(rc: two_lock_queue::Receiver<Task>, cfg: &std::sync::Arc<Config>){
    for _ in 0..cfg.threads{
        let rc_cp  = rc.clone();
        let cfg_c = cfg.clone();
        thread::spawn(move || {
            loop {
                match rc_cp.recv(){
                    Ok(t) => {
                        run(&cfg_c, &t.path, t.idx);
                        DONE.fetch_add(1, Ordering::SeqCst);
                    },
                    _ => break
                }
            }
        });
    }
}

fn send_file_tasks(sd: two_lock_queue::Sender<Task>, cfg: &std::sync::Arc<Config>){
    for entry in cfg.fd_in.read_dir().unwrap(){
        if let Ok(entry) = entry{
            if !entry.file_name().to_str().unwrap().ends_with(".txt"){
                continue;
            }
            let i = get_number(entry.file_name().to_str().unwrap());
            if !cfg.rg.contains(&i){
                continue;
            }
            let task = Task{
                idx: i,
                path: entry.path()
            };
            sd.send(task).unwrap();
        }

    }
}

pub fn launch(args: &ArgMatches){
    let cfg = std::sync::Arc::from(get_config(args));
    let all =  cfg.rg.end() - cfg.rg.start() + 1;

    let bar = ProgressBar::new(all as u64);
    bar.set_style(ProgressStyle::default_bar()
        .template("[{elapsed}] {wide_bar} {pos}/{len}")
        .progress_chars("## ")
    );
    bar.inc(0);

    let (task_sender, task_receiver) = two_lock_queue::channel::<Task>(all+1);
    launch_threads(task_receiver, &cfg);
    send_file_tasks(task_sender, &cfg);

    let mut last = DONE.load(Ordering::SeqCst);
    while last < all{
        let cur = DONE.load(Ordering::SeqCst);
        let delta = cur - last;
        if delta > 0 {  
            bar.inc(delta as u64);
        }
        last = cur;
        std::thread::sleep(std::time::Duration::from_millis(100));
    }

    bar.finish();
}